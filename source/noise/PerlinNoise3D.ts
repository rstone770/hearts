import { fract, lerp } from "@hearts/math/utilities";
import { arrayToVector3DLiteral, Vector3DLiteral } from "@hearts/math/Vector3D";
import { NoiseFunction3D, NoiseGenerator3D } from "./Noise";

type Perlin3DFadeFunction = (t: number) => number;
type Perlin3DGradientFunction = (x: number, y: number, z: number) => Vector3DLiteral;

// prettier-ignore
const PERMUTATION_TABLE: Array<number> = [
    0x97, 0xa0, 0x89, 0x5b, 0x5a, 0x0f, 0x83, 0x0d, 0xc9, 0x5f, 0x60, 0x35, 0xc2, 0xe9, 0x07, 0xe1,
    0x8c, 0x24, 0x67, 0x1e, 0x45, 0x8e, 0x08, 0x63, 0x25, 0xf0, 0x15, 0x0a, 0x17, 0xbe, 0x06, 0x94,
    0xf7, 0x78, 0xea, 0x4b, 0x00, 0x1a, 0xc5, 0x3e, 0x5e, 0xfc, 0xdb, 0xcb, 0x75, 0x23, 0x0b, 0x20,
    0x39, 0xb1, 0x21, 0x58, 0xed, 0x95, 0x38, 0x57, 0xae, 0x14, 0x7d, 0x88, 0xab, 0xa8, 0x44, 0xaf,
    0x4a, 0xa5, 0x47, 0x86, 0x8b, 0x30, 0x1b, 0xa6, 0x4d, 0x92, 0x9e, 0xe7, 0x53, 0x6f, 0xe5, 0x7a,
    0x3c, 0xd3, 0x85, 0xe6, 0xdc, 0x69, 0x5c, 0x29, 0x37, 0x2e, 0xf5, 0x28, 0xf4, 0x66, 0x8f, 0x36,
    0x41, 0x19, 0x3f, 0xa1, 0x01, 0xd8, 0x50, 0x49, 0xd1, 0x4c, 0x84, 0xbb, 0xd0, 0x59, 0x12, 0xa9,
    0xc8, 0xc4, 0x87, 0x82, 0x74, 0xbc, 0x9f, 0x56, 0xa4, 0x64, 0x6d, 0xc6, 0xad, 0xba, 0x03, 0x40,
    0x34, 0xd9, 0xe2, 0xfa, 0x7c, 0x7b, 0x05, 0xca, 0x26, 0x93, 0x76, 0x7e, 0xff, 0x52, 0x55, 0xd4,
    0xcf, 0xce, 0x3b, 0xe3, 0x2f, 0x10, 0x3a, 0x11, 0xb6, 0xbd, 0x1c, 0x2a, 0xdf, 0xb7, 0xaa, 0xd5,
    0x77, 0xf8, 0x98, 0x02, 0x2c, 0x9a, 0xa3, 0x46, 0xdd, 0x99, 0x65, 0x9b, 0xa7, 0x2b, 0xac, 0x09,
    0x81, 0x16, 0x27, 0xfd, 0x13, 0x62, 0x6c, 0x6e, 0x4f, 0x71, 0xe0, 0xe8, 0xb2, 0xb9, 0x70, 0x68,
    0xda, 0xf6, 0x61, 0xe4, 0xfb, 0x22, 0xf2, 0xc1, 0xee, 0xd2, 0x90, 0x0c, 0xbf, 0xb3, 0xa2, 0xf1,
    0x51, 0x33, 0x91, 0xeb, 0xf9, 0x0e, 0xef, 0x6b, 0x31, 0xc0, 0xd6, 0x1f, 0xb5, 0xc7, 0x6a, 0x9d,
    0xb8, 0x54, 0xcc, 0xb0, 0x73, 0x79, 0x32, 0x2d, 0x7f, 0x04, 0x96, 0xfe, 0x8a, 0xec, 0xcd, 0x5d,
    0xde, 0x72, 0x43, 0x1d, 0x18, 0x48, 0xf3, 0x8d, 0x80, 0xc3, 0x4e, 0x42, 0xd7, 0x3d, 0x9c, 0xb4
];

const PERMUTATION_TABLE_2: Array<number> = [...PERMUTATION_TABLE, ...PERMUTATION_TABLE];

const hash = (x: number, y: number, z: number) => {
    const x0 = x;
    const y0 = y;
    const z0 = z;
    const p = PERMUTATION_TABLE_2;

    return p[p[p[x0] + y0] + z0];
};

// prettier-ignore
const GRADIENT_VECTORS: Array<Vector3DLiteral> = [
    [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
    [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
    [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1],
    [1, 1, 0], [0, -1, 1], [-1, 1, 0], [0, -1, -1]
    
].map(arrayToVector3DLiteral);

const grad: Perlin3DGradientFunction = (x: number, y: number, z: number) => {
    return GRADIENT_VECTORS[hash(x, y, z) & 0xf];
};

const fade: Perlin3DFadeFunction = (t) => t * t * t * (t * (t * 6 - 15) + 10);

const dot = (g: Vector3DLiteral, x: number, y: number, z: number) => {
    return g.x * x + g.y * y + g.z * z;
};

interface PerlinNoise3DOptions {
    fade: Perlin3DFadeFunction;
    grad: Perlin3DGradientFunction;
}

const DEFAULT_OPTIONS: PerlinNoise3DOptions = {
    fade,
    grad
};

export class PerlinNoise3D implements NoiseGenerator3D {
    private readonly fade: Perlin3DFadeFunction;
    private readonly grad: Perlin3DGradientFunction;

    public static readonly default: PerlinNoise3D = new PerlinNoise3D();

    public constructor(options?: Partial<PerlinNoise3DOptions>) {
        this.fade = options?.fade ?? DEFAULT_OPTIONS.fade;
        this.grad = options?.grad ?? DEFAULT_OPTIONS.grad;
    }

    public eval(x: number, y: number, z: number) {
        const x0 = x & 0xff;
        const y0 = y & 0xff;
        const z0 = z & 0xff;
        const dx = fract(x);
        const dy = fract(y);
        const dz = fract(z);
        const fade = this.fade;
        const grad = this.grad;

        const u = fade(dx);
        const v = fade(dy);
        const w = fade(dz);

        const g000 = grad(x0, y0, z0);
        const g001 = grad(x0, y0, z0 + 1);
        const g010 = grad(x0, y0 + 1, z0);
        const g011 = grad(x0, y0 + 1, z0 + 1);
        const g100 = grad(x0 + 1, y0, z0);
        const g101 = grad(x0 + 1, y0, z0 + 1);
        const g110 = grad(x0 + 1, y0 + 1, z0);
        const g111 = grad(x0 + 1, y0 + 1, z0 + 1);

        const q00 = lerp(dot(g000, dx, dy, dz), dot(g100, dx - 1, dy, dz), u);
        const q10 = lerp(dot(g010, dx, dy - 1, dz), dot(g110, dx - 1, dy - 1, dz), u);
        const q01 = lerp(dot(g001, dx, dy, dz - 1), dot(g101, dx - 1, dy, dz - 1), u);
        const q11 = lerp(dot(g011, dx, dy - 1, dz - 1), dot(g111, dx - 1, dy - 1, dz - 1), u);

        const n0 = lerp(q00, q10, v);
        const n1 = lerp(q01, q11, v);

        return (lerp(n0, n1, w) + 1) / 2;
    }
}

export const noise: NoiseFunction3D = (x: number, y: number, z: number) => {
    return PerlinNoise3D.default.eval(x, y, z);
};
